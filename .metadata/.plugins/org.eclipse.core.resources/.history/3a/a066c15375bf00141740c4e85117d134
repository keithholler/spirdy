display.setStatusBar(display.HiddenStatusBar)

local composer = require( "composer" )
local scene = composer.newScene()

local widget = require( "widget" )
--local score = require( "score" )
--local music = require("bgMusic")
local physics = require("physics")
local time = require("timer")
local particles = require("particleDesigner")
local Analog = require("analogStick")
local myData = require ("myData")
local mcx = require("mcx")

local centerY = display.contentCenterY
local centerX = display.contentCenterX
local W = display.contentWidth
local H = display.contentHeight
local screenLeft = display.screenOriginX
local screenWidth = display.viewableContentWidth - screenLeft * 2
local screenRight = screenLeft + screenWidth
local screenTop = display.screenOriginY
local screenHeight = display.viewableContentHeight - screenTop * 2
local screenBottom = screenTop + screenHeight
local screenTopSB = screenTop + display.topStatusBarContentHeight
local screenHeightSB = display.viewableContentHeight - screenTopSB
local screenBottomSB = screenTopSB + screenHeightSB

physics.start()
physics.setGravity(0,0)
physics.setContinuous(true)

local group = {}
local wall1, wall2, wall3, wall4, Text, gemCounter, coinCounter, coinFont, background, background2, background3, 
  stars1, stars2, stars3, pause, cloud1, cloud2, cloud3
  
local op5, gem

--physics.setDrawMode( "hybrid" )

-- -----------------------------------------------------------------------------------------------------------------
-- All code outside of the listener functions will only be executed ONCE unless "composer.removeScene()" is called.
-- -----------------------------------------------------------------------------------------------------------------

-- local forward references should go here

--------------------------
 --   Timer Functions   --
--------------------------
-------------------------------------------------------------------------------------------------------
      function timer:createTimer(delay, listener, iterations)
        local id = null
        id = timer.performWithDelay( delay, listener, iterations )
        table.insert(group,id)
      
        -- Garbage Collection
        if iterations ~= nil and iterations ~= 0 then
          timer.performWithDelay( delay*iterations+100, function(self)
            timer:destroyTimer(id)
          end, 1 )
        end
        return id
      end
      
      -- Find ID of timer in table and destroy it
      function timer:destroyTimer(id)
        for i=1, table.maxn(group), 1 do
          if group[i] == id then
            timer.cancel(id)
            table.remove(group,i)
            return true
          end
        end
          return false
      end
      
      function timer:flushAllTimers()
        for i=table.maxn(group), 1, -1 do
          timer.cancel(group[i])
          table.remove(group,i)
        end
      end
      
      function timer:pauseAllTimers()
        for i=1, table.maxn(group), 1 do
          timer.pause(group[i])
        end
      end
      
      function timer:resumeAllTimers()
        for i=1, table.maxn(group), 1 do
          timer.resume(group[i])
        end
      end 
-------------------------------------------------------------------------------------------------------

local function pause(event)
  local go = event.target.id
  if go == "pause" then
    composer.showOverlay(go, {isModal = true})
    physics.pause()
    transition.pause()
    timer:pauseAllTimers()
    --music.atroxOff()
    myData.bgScrollSpeed = 0
    myData.planetScrollSpeed = 0
    pause.alpha = 0
   end
end

function scene:resume()
   physics.start()
   transition.resume()
   timer:resumeAllTimers()
   --music.atroxOn()
   myData.bgScrollSpeed = 0.4
   myData.planetScrollSpeed = 0.8
   pause.alpha = 1
end

-- Deletes data when pressing the retry button
function scene:remove()
  background:removeSelf()
  background = nil
  background2:removeSelf()
  background2 = nil
  background3:removeSelf()
  background3 = nil
  
  stars1:removeSelf()
  stars1 = nil
  stars2:removeSelf()
  stars2 = nil
  stars3:removeSelf()
  stars3 = nil
  
  cloud1:removeSelf()
  cloud1 = nil
  cloud2:removeSelf()
  cloud2 = nil
  cloud3:removeSelf()
  cloud3 = nil
  
  wall1:removeSelf()
  wall1 = nil
  wall2:removeSelf()
  wall2 = nil
  wall3:removeSelf()
  wall3 = nil
  wall4:removeSelf()
  wall4 = nil
  
  gem:removeSelf()
  gem = nil
  
  op5:removeSelf()
  op5 = nil
  
end

-- "scene:create()"
function scene:create( event )

    local sceneGroup = self.view
    
    -- Initialize the scene here.
    -- Example: add display objects to "sceneGroup", add touch listeners, etc.
      wall1 = display.newRect(sceneGroup, 0, display.contentHeight/2, 2, display.contentHeight )
      wall2 = display.newRect(sceneGroup, display.contentWidth/2, 0, display.contentWidth, 2 )
      wall3 = display.newRect(sceneGroup, display.contentWidth, display.contentHeight/2, 0, display.contentHeight )
      wall4 = display.newRect(sceneGroup, display.contentWidth/2, display.contentHeight , display.contentWidth, 2 )

      -- Create bounding wall for the level
      physics.addBody( wall1, "kinematic", wallMaterial )
      physics.addBody( wall2, "kinematic", wallMaterial )
      physics.addBody( wall3, "kinematic", wallMaterial )
      physics.addBody( wall4, "kinematic", wallMaterial )
      
      ----------------------
      --    Background/UI    --
      ----------------------
-------------------------------------------------------------------------------------------------------
      Text = display.newText(sceneGroup, " ", W*.6, H-20, native.systemFont, 15 )
      background = display.newImageRect(sceneGroup, "bg/bg1Part1.png", 712.5, 450)
      background2 = display.newImageRect(sceneGroup, "bg/bg1Part2.png", 712.5, 450)
      background3 = display.newImageRect(sceneGroup, "bg/bg1Part3.png", 712.5, 450)
      stars1 =  display.newImageRect(sceneGroup, "bg/stars1.png", 712.5, 450)
      stars2 =  display.newImageRect(sceneGroup, "bg/stars2.png", 712.5, 450)
      stars3 =  display.newImageRect(sceneGroup, "bg/stars3.png", 712.5, 450)
      cloud1 =  display.newImageRect(sceneGroup, "bg/clouds1.png", 712.5, 450)
      cloud2 =  display.newImageRect(sceneGroup, "bg/clouds2.png", 712.5, 450)
      cloud3 =  display.newImageRect(sceneGroup, "bg/clouds3.png", 712.5, 450)

      -- Variables for the in-game displays
      gemCounter = display.newImageRect(sceneGroup, "gameUI/counter_gem.png", 140, 60)
      coinCounter = display.newImageRect(sceneGroup, "gameUI/counter_coin.png", 140, 60)
      coinFont = display.newText(sceneGroup, "1", 0, 0, "Soup Of Justice", 24)
      
      background:scale(1, 1)
      background.anchorX = 0;
      background.anchorY = .5;
      background.x = 0; background.y = H/2;
  
      background2:scale(1, 1)
      background2.anchorX = 0;
      background2.anchorY = 0.5;
      background2.x = 712.5; background2.y = H/2;
  
      background3:scale(1, 1)
      background3.anchorX = 0;
      background3.anchorY = 0.5;
      background3.x = 1425; background3.y = H/2;
  
      stars1:scale(1, 1)
      stars1.anchorX = 0;
      stars1.anchorY = .5;
      stars1.x = 0; stars1.y = H/2;
  
      stars2:scale(1, 1)
      stars2.anchorX = 0;
      stars2.anchorY = 0.5;
      stars2.x = 712.5; stars2.y = H/2;
  
      stars3:scale(1, 1)
      stars3.anchorX = 0;
      stars3.anchorY = 0.5;
      stars3.x = 1425; stars3.y = H/2;
      
      cloud1:scale(1, 1)
      cloud1.anchorX = 0;
      cloud1.anchorY = 0.5;
      cloud1.x = 0; cloud1.y = H/2;
  
      cloud2:scale(1, 1)
      cloud2.anchorX = 0;
      cloud2.anchorY = 0.5;
      cloud2.x = 712.5; cloud2.y = H/2;
  
      cloud3:scale(1, 1)
      cloud3.anchorX = 0;
      cloud3.anchorY = 0.5;
      cloud3.x = 1425; cloud3.y = H/2;
  
      coinCounter.x = 210
      coinCounter.y = 29
      coinCounter.alpha = 1
  
      gemCounter.x = 65
      gemCounter.y = 30
      gemCounter.alpha = 1
  
      coinFont:setFillColor( 0, 0, 0 )
      coinFont.anchorX = 0
      coinFont.x = 245
      coinFont.y = 32
      
      pause = widget.newButton
      {
        width = 40,
        height = 40,
        defaultFile = "pause.png",
        id = "pause",
        onRelease = pause
      }
    
      pause.x = 650
      pause.y = 30
      pause.alpha = 0.7
      sceneGroup:insert(pause)
end

-- "scene:show()"
function scene:show( event )

    local sceneGroup = self.view
    local phase = event.phase

    if ( phase == "will" ) then
      -- Called when the scene is still off screen (but is about to come on screen).
      --composer.removeScene("loadIntro")
      --composer.removeScene("levelSelNorm")
      --composer.removeScene("retry")
      --score.reset()
      
        --music.Atrox()
        function move(event)
  
          background.x = background.x - myData.bgScrollSpeed
          background2.x = background2.x - myData.bgScrollSpeed
          background3.x = background3.x - myData.bgScrollSpeed
        
          if(background.x + background.contentWidth) < -712.5 then
            background:translate(712.5*3, 0)
          end
        
          if(background2.x + background2.contentWidth) < -712.5 then
            background2:translate(712.5*3, 0)
          end
        
          if(background3.x + background3.contentWidth) < -712.5 then
            background3:translate(712.5*3, 0)
          end
        end
  
      Runtime:addEventListener("enterFrame", move)
  
      function move2(event)
  
        stars1.x = stars1.x - myData.starScrollSpeed
        stars2.x = stars2.x - myData.starScrollSpeed
        stars3.x = stars3.x - myData.starScrollSpeed
          
        if(stars1.x + stars1.contentWidth) < -712.5 then
          stars1:translate(712.5*3, 0)
        end
          
        if(stars2.x + stars2.contentWidth) < -712.5 then
          stars2:translate(712.5*3, 0)
        end
          
        if(stars3.x + stars3.contentWidth) < -712.5 then
          stars3:translate(712.5*3, 0)
        end
      end
  
      Runtime:addEventListener("enterFrame", move2)
      
      function move3(event)
  
        cloud1.x = cloud1.x - myData.planetScrollSpeed
        cloud2.x = cloud2.x - myData.planetScrollSpeed
        cloud3.x = cloud3.x - myData.planetScrollSpeed
          
        if(cloud1.x + cloud1.contentWidth) < -712.5 then
          cloud1:translate(712.5*3, 0)
        end
          
        if(cloud2.x + cloud2.contentWidth) < -712.5 then
          cloud2:translate(712.5*3, 0)
        end
          
        if(cloud3.x + cloud3.contentWidth) < -712.5 then
          cloud3:translate(712.5*3, 0)
        end
      end
  
      Runtime:addEventListener("enterFrame", move3)
      
    elseif ( phase == "did" ) then
        -- Called when the scene is now on screen.
        -- Insert code here to make the scene come alive.
        -- Example: start timers, begin animation, play audio, etc.
        local char = mcx.new()
        local charDies = mcx.new()

        char:enableDebugging()
        charDies:enableDebugging()
        
        local physicsIdle = (require "idle00").physicsData(1)
        local physicsBack = (require "backwards00").physicsData(1)
        local physicsUp = (require "up00").physicsData(1)
        local physicsDown = (require "down00").physicsData(1)
        local physicsForward = (require "forwards00").physicsData(1)

      -- Set parameters for the Analog stick
      MyStick = Analog.NewStick({x = 55, y = 265, thumbSize = 25, borderSize = 45, 
            snapBackSpeed = .75, R = 255, G = 255, B = 255})
            sceneGroup:insert(MyStick)

      local scoreText = score.init({fontSize = 20, font = "Soup Of Justice", x = 90, y = 32, maxDigits = 5, leadingZeros = false, filename = "scorefile.txt",})
        scoreText:setFillColor(0, 0, 0)
        sceneGroup:insert(scoreText)
      
-------------------------------------------------------------------------------------------------------

    ----------------
    --    Gems    --
    ----------------
-------------------------------------------------------------------------------------------------------
    -- In your sequences, add the parameter 'sheet =', referencing which image sheet the sequence should be used
    -- local variables for the Gems
    local sequenceData = {{ name="Gem1", start=1, count=5, time=800, loopCount=0 }}
    local SheetInfo = { width = 40, height = 60, numFrames = 5, sheetContentWidth = 200, sheetContentHeight = 60}
    local redSheet = graphics.newImageSheet("redGemsSprites.png", SheetInfo)
    local greenSheet = graphics.newImageSheet("greenGemsSprites.png", SheetInfo)
      
    local function genGems()
      local gems = {redSheet, greenSheet}
      local gemRan = gems[math.random(#gems)];
      local gemPhysData = (require "blueGem01").physicsData(1.0)
      
      gem = display.newSprite(sceneGroup, gemRan, sequenceData);
  
      gem.Gems = gemRan
        
      physics.addBody( gem, "kinematic", gemPhysData:get("blueGem01"))
      
      gem.y = 1 + math.random( 450 ) 
      gem.x = 800
      gem:setSequence( "Gem1" )
      
      gem.type = "gems1"
      gem.value = 1
      gem:play()
      
      local function gemsRemove(target)
        physics.removeBody(target)
        target:removeSelf()
        target = nil
      end
      
        transition.to(gem, {time = 4500,x=(W-900), onComplete = gemsRemove, tag = "transTag"})
        
        -- After a short time, swap the sequence to 'seq2' which uses the second image sheet
        local function swapSheet()
               gem:setSequence( "Gem1" )
               gem:play()
        end
    end

    local physicsData = (require "levels.normalMode.level1.level1Physics").physicsData(1.0)
    
    local opMove5 = function()

        op5 = display.newImageRect(sceneGroup, "levels/normalMode/level1/obstacle5.png",598,450)
        
        physics.addBody(op5, "kinematic", physicsData:get("obstacle5") )
        op5.x = 1000
        op5.y = 200
        op5.type = "obstacle"
        
        local function op5Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op5, {time = 10000,x=(W-2000), onComplete = op5Remove, tag = "transTag"})
    end

    --[[local opMove3 = function()

        local op3 = display.newImageRect(sceneGroup, "levels/normalMode/level1/obstacle6.png",379,396)
      
        physics.addBody(op3, "kinematic", physicsData:get("obstacle6") )
        op3.rotation = 400
        op3.x = 1000
        op3.y = 175
        op3.type = "obstacle"
        
        local function op3Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
        
        transition.to(op3, {time = 10000,x=(W-2000), onComplete = op3Remove, tag = "transTag"})
        
        local function Lshaperotate()
          transition.to(op3, {time = 2500,rotation = op3.rotation-360, onComplete = Lshaperotate, tag = "transTag"})
        end
        
        Lshaperotate()
    end

    local opMove2 = function()

        local op2 = display.newImageRect(sceneGroup, "levels/normalMode/level1/obstacle2.png",478,450)

        physics.addBody(op2, "kinematic", physicsData:get("obstacle2") )
        op2.x = 1000
        op2.y = 200
        op2.type = "obstacle"
        
        local function op2Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op2,{time = 10000,x=(W-2000), onComplete = op2Remove, tag = "transTag"})
    end

    local opMove1 = function()

        local op1 = display.newImageRect(sceneGroup, "levels/normalMode/level1/obstacle1.png",491,450)
      
        physics.addBody(op1, "kinematic", physicsData:get("obstacle1") )
        op1.x = 1000
        op1.y = 200
        op1.type = "obstacle"
        
        local function op1Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op1,{time = 10000,x=(W-2000), onComplete = op1Remove, tag = "transTag"})
    end
    
    local opMove4 = function()

        local op4 = display.newImageRect(sceneGroup, "levels/normalMode/level1/obstacle3.png",663,450)
        local op4C = display.newImageRect(sceneGroup, "levels/normalMode/level1/obstacle6.png",379,396) 
        
        physics.addBody(op4, "kinematic", physicsData:get("obstacle3") )
        op4.x = 1000
        op4.y = 200
        op4.type = "obstacle"
        
        physics.addBody(op4C, "kinematic", physicsData:get("obstacle6") )
        op4C.x = 1000
        op4C.y = 200
        op4C.type = "obstacle"
        
        local function op4Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op4C,{time = 10000,x=(W-2000), onComplete = op4Remove, tag = "transTag"})
      
        transition.to(op4,{time = 10000,x=(W-2000), onComplete = op4Remove, tag = "transTag"})
        
        local function cRotate()
          transition.to(op4C,{time = 2500,rotation = op4C.rotation-360, onComplete = cRotate, tag = "transTag"})
        end
        
        cRotate()
    end
    
    local opMove6 = function()

        local op6 = display.newImageRect(sceneGroup, "levels/normalMode/level1/ob_1.png",490,450)
      
        physics.addBody(op6, "kinematic", physicsData:get("ob_1") )
        op6.x = 1000
        op6.y = 200
        op6.type = "obstacle"
        
        local function op6Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op6,{time = 10000,x=(W-2000), onComplete = op6Remove, tag = "transTag"})
    end
    
    local opMove7 = function()

        local op7 = display.newImageRect(sceneGroup, "levels/normalMode/level1/ob_2.png",691,441)
      
        physics.addBody(op7, "kinematic", physicsData:get("ob_2") )
        op7.x = 1000
        op7.y = 200
        op7.type = "obstacle"
        
        local function op7Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op7,{time = 10000,x=(W-2000), onComplete = op7Remove, tag = "transTag"})
    end
    
    local opMove8 = function()

        local op8 = display.newImageRect(sceneGroup, "levels/normalMode/level1/ob_3.png",547,436)
      
        physics.addBody(op8, "kinematic", physicsData:get("ob_3") )
        op8.x = 1000
        op8.y = 200
        op8.type = "obstacle"
        
        local function op8Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op8,{time = 10000,x=(W-2000), onComplete = op8Remove, tag = "transTag"})
    end
    
    local opMove9 = function()

        local op9 = display.newImageRect(sceneGroup, "levels/normalMode/level1/ob_5.png",595,450)
      
        physics.addBody(op9, "kinematic", physicsData:get("ob_5") )
        op9.x = 1000
        op9.y = 200
        op9.type = "obstacle"
        
        local function op9Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op9,{time = 10000,x=(W-2000), onComplete = op9Remove, tag = "transTag"})
    end
    
    local opMove10 = function()

        local op10 = display.newImageRect(sceneGroup, "levels/normalMode/level1/ob_6.png",412,450)
      
        physics.addBody(op10, "kinematic", physicsData:get("ob_6") )
        op10.x = 1000
        op10.y = 200
        op10.type = "obstacle"
        
        local function op10Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op10,{time = 10000,x=(W-2000), onComplete = op10Remove, tag = "transTag"})
    end
    
    local opMove11 = function()

        local op11 = display.newImageRect(sceneGroup, "levels/normalMode/level1/ob_7.png",380,450)
      
        physics.addBody(op11, "kinematic", physicsData:get("ob_7") )
        op11.x = 1000
        op11.y = 200
        op11.type = "obstacle"
        
        local function op11Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op11,{time = 10000,x=(W-2000), onComplete = op11Remove, tag = "transTag"})
    end
    
    local opMove12 = function()

        local op12 = display.newImageRect(sceneGroup, "levels/normalMode/level1/ob_9.png",262,450)
      
        physics.addBody(op12, "kinematic", physicsData:get("ob_9") )
        op12.x = 1000
        op12.y = 200
        op12.type = "obstacle"
        
        local function op12Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op12,{time = 10000,x=(W-2000), onComplete = op12Remove, tag = "transTag"})
    end
    
    local opMove13 = function()

        local op13 = display.newImageRect(sceneGroup, "levels/normalMode/level1/ob_10.png",374,450)
      
        physics.addBody(op13, "kinematic", physicsData:get("ob_10") )
        op13.x = 1000
        op13.y = 200
        op13.type = "obstacle"
        
        local function op13Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op13,{time = 10000,x=(W-2000), onComplete = op13Remove, tag = "transTag"})
    end
    
    local opMove14 = function()

        local op14 = display.newImageRect(sceneGroup, "levels/normalMode/level1/ob_11.png",414,450)
      
        physics.addBody(op14, "kinematic", physicsData:get("ob_11") )
        op14.x = 1000
        op14.y = 200
        op14.type = "obstacle"
        
        local function op14Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op14,{time = 10000,x=(W-2000), onComplete = op14Remove, tag = "transTag"})
    end
    
    local opMove15 = function()

        local op15 = display.newImageRect(sceneGroup, "levels/normalMode/level1/ob_12.png",266,450)
      
        physics.addBody(op15, "kinematic", physicsData:get("ob_12") )
        op15.x = 1000
        op15.y = 200
        op15.type = "obstacle"
        
        local function op15Remove(target)
          physics.removeBody(target)
          target:removeSelf()
          target = nil
        end
      
        transition.to(op15,{time = 10000,x=(W-2000), onComplete = op15Remove, tag = "transTag"})
    end]]--

    local pick = function()
      Object = math.ceil(math.random(1,15))
      --if Object == 1 then opMove1()  
      --elseif Object == 2 then opMove2()
      --elseif Object == 3 then opMove3()
      --elseif Object == 4 then opMove4()  
      if Object == 5 then opMove5()
      --elseif Object == 6 then opMove6()
      --elseif Object == 7 then opMove7()
      --elseif Object == 8 then opMove8()
      --elseif Object == 9 then opMove9()
      --elseif Object == 10 then opMove10()
      --elseif Object == 11 then opMove11()
      --elseif Object == 12 then opMove12()
      --elseif Object == 13 then opMove13()
      --elseif Object == 14 then opMove14()
      --elseif Object == 15 then opMove15()
      end
    end

    timer:createTimer(2500, pick, 99999)
    timer:createTimer( math.random(1000,4000), genGems, 99999)
------------------------------------------------------------------------------------------------------
    
     -- Spirdy collision function can add more to function if needed
     function collision(self, event)
      if event.phase == "began" then 
        --Collision with asteroids
        if self.type == "player"  and event.other.type == "obstacle" then
        
          local function trans()
            Text:removeSelf()
            Text = nil
            pause:removeSelf()
            pause = nil
            scoreText:removeSelf()
            scoreText = nil
            gemCounter:removeSelf()
            gemCounter = nil
            coinCounter:removeSelf()
            coinCounter = nil
            coinFont:removeSelf()
            coinFont = nil
            --myStick:removeSelf()
            --myStick = nil
            gem:pause()
            
            transition.cancel()
            timer:destroyTimer(pick)
            timer:destroyTimer(genGems)
            timer:destroyTimer(tapAnalog)
            
            char:remove()
            charDies:remove()
            
            composer.showOverlay("gameOver")
          end
          
          --highsaveScore()
          
          if char:currentAnimation() == "back" or char:currentAnimation() == "up" or char:currentAnimation() == "down" or
          char:currentAnimation() == "forward" or char:currentAnimation() == "idle" then
            Runtime:removeEventListener("enterFrame", move)
            Runtime:removeEventListener("enterFrame", move2)
            Runtime:removeEventListener("enterFrame", move3)
            Runtime:removeEventListener( "enterFrame", main )
            Runtime:removeEventListener("touch", moveAnalog)
            char:removeEventListener("collision", char)
            
            transition.cancel("transTag")
            timer:pauseAllTimers()
            --music.remove()
            
            charDies:newAnim("dead", 
              mcx.sequence({name = "playerSel/characters/spirdy/gameOverAnim/dies",
              extension = "png",
              endFrame = 24,
              zeros = 2}),
            351, 330,
            {speed = 1, loops = 1})
            
            char:stop()
            
            charDies:play({name = "dead"})
            transition.to(charDies, {delay = 1000, onComplete = trans})
           end
           
        -- Collision with gems 
        elseif self.type == "player" and event.other.type == "gems1" or event.other.type == "gems2" then
          --score.add(event.other.value)
          event.other.alpha = 0
          --Makes the type not equal so the collision is not dected this is to keep the collision at 1
          if event.other.type =="gems1" or event.other.type == "gems2" then
            event.other.type = "none"
          end
        end
      end
    end

    -- Listens for the Analog stick
    function moveAnalog(e)
        if e.phase == "began" then
          MyStick.x = e.x
          MyStick.y = e.y
          e.target = MyStick.Thumb
          e.phase = "began"
          MyStick.onDrag(e)

        elseif e.phase == "moved" then
          timer.createTimer(0, transition.cancel(tapAnalog))
      end  
    end

    Runtime:addEventListener("touch", moveAnalog)
    
    char:newAnim("idle", 
        mcx.sequence({name = "playerSel/characters/spirdy/idleAnim/idle",
          extension = "png",
          endFrame = 10,
          zeros = 2}),
        57, 86,
        {speed = 2, loops = -1})
        
    char:newAnim("forward", 
        mcx.sequence({name = "playerSel/characters/spirdy/forwardAnim/fwd",
          extension = "png",
          endFrame = 8,
          zeros = 2}),
        62, 84,
        {speed = 2, loops = -1})
        
    char:newAnim("back", 
        mcx.sequence({name = "playerSel/characters/spirdy/backAnim/back",
          extension = "png",
          endFrame = 8,
          zeros = 2}),
        68, 84,
        {speed = 2, loops = -1})
        
    char:newAnim("up", 
        mcx.sequence({name = "playerSel/characters/spirdy/upAnim/up",
          extension = "png",
          endFrame = 8,
          zeros = 2}),
        55, 85,
        {speed = 2, loops = -1})
        
    char:newAnim("down", 
        mcx.sequence({name = "playerSel/characters/spirdy/downAnim/down",
          extension = "png",
          endFrame = 8,
          zeros = 2}),
        66, 85,
        {speed = 2, loops = -1})
    
    char.x = W*.5
    char.y = H*.5
    charDies.x = W*.5
    charDies.y = H*.5
    
    -- Sets player to a type object for collision listener
    char.type = "player"
    char.collision = collision 
    char:addEventListener("collision", char)
    physics.addBody(char, "dynamic", physicsIdle:get("idle00") )
    
    char:play({name = "idle"})
    
    char.isFixedRotation = true
    charDies.isFixedRotation = true
    
    sceneGroup:insert(char)
    sceneGroup:insert(charDies)
    
    -- Moves Spirdy around the level
    function main( event )
        -- moves both the sprite sheet (bird1) and the physics image (spirdy)
        MyStick:move(char, 6.0, false)
        MyStick:move(charDies, 6.0, false)
        
        -- MOST IMPORTANT PART MAKES BIRD1 STICK TO SPIRDY EVEN IF THE PHYSICS HITS A WALL
        -- MAKING THE SPRITE SHEET NOT FLY OFF THE SCREEN
        -- Makes spirdy move forward depending on angle
          if MyStick:getAngle()>= 45 and MyStick:getAngle()<= 135 and char:currentAnimation() == "up" or MyStick:getAngle()>= 45 and MyStick:getAngle()<= 135 and char:currentAnimation() == "down" or
          MyStick:getAngle()>= 45 and MyStick:getAngle()<= 135 and char:currentAnimation() == "back" or MyStick:getAngle()>= 45 and MyStick:getAngle()<= 135 and char:currentAnimation() == "idle" then
            physics.removeBody(char)
            char:play({name = "forward"})

            physics.addBody(char, "dynamic", physicsForward:get("forwards00") )
            char.isFixedRotation = true
            char.type = "player"
            
          -- Makes spirdy move backwards depending on angle       
          elseif MyStick:getAngle()>= 225 and MyStick:getAngle()<= 315 and char:currentAnimation() == "up" or MyStick:getAngle()>= 225 and MyStick:getAngle()<= 315 and char:currentAnimation() == "down" or
          MyStick:getAngle()>= 225 and MyStick:getAngle()<= 315 and char:currentAnimation() == "forward" or MyStick:getAngle()>= 225 and MyStick:getAngle()<= 315 and char:currentAnimation() == "idle" then
            physics.removeBody(char)
            char:play({name = "back"})

            physics.addBody(char, "dynamic", physicsBack:get("backwards00") )
            char.isFixedRotation = true
            char.type = "player"
            
          -- Makes spirdy move upwards depending on angle
          elseif MyStick:getAngle()> 315 and MyStick:getAngle()<= 360 and char:currentAnimation() == "back" or MyStick:getAngle()> 0 and MyStick:getAngle()< 45 and char:currentAnimation() == "back" or
          MyStick:getAngle()> 315 and MyStick:getAngle()<= 360 and char:currentAnimation() == "forward" or MyStick:getAngle()> 0 and MyStick:getAngle()< 45 and char:currentAnimation() == "forward" or
          MyStick:getAngle()> 315 and MyStick:getAngle()<= 360 and char:currentAnimation() == "down" or MyStick:getAngle()> 0 and MyStick:getAngle()< 45 and char:currentAnimation() == "down" or 
          MyStick:getAngle()> 315 and MyStick:getAngle()<= 360 and char:currentAnimation() == "idle" or MyStick:getAngle()> 0 and MyStick:getAngle()< 45 and char:currentAnimation() == "idle" then
            physics.removeBody(char)
            char:play({name = "up"})

            physics.addBody(char, "dynamic", physicsUp:get("up00") )
            char.isFixedRotation = true
            char.type = "player"
            
          -- Makes spirdy move downwards depending on angle
          elseif MyStick:getAngle()> 135 and MyStick:getAngle()< 225 and char:currentAnimation() == "back" or MyStick:getAngle()> 135 and MyStick:getAngle()< 225 and char:currentAnimation() == "forward" or
          MyStick:getAngle()> 135 and MyStick:getAngle()< 225 and char:currentAnimation() == "up" or MyStick:getAngle()> 135 and MyStick:getAngle()< 225 and char:currentAnimation() == "idle" then
            physics.removeBody(char)
            char:play({name = "down"})

            physics.addBody(char, "dynamic", physicsDown:get("down00") )
            char.isFixedRotation = true
            char.type = "player"
      end
    end
 
    Runtime:addEventListener( "enterFrame", main )
    
  --[[function highsaveScore()
      if score.get() == 0 then
      print("test")
      elseif
        score.get() > score.load() then
        score.save()
            end
            return true
          end
   

  function firstloadScore( )
      if score.load() == nil then
       score.save()
     end
   end

      function resetScore()
        local prevScore = score.load()
        if prevScore then
          score.reset()
          score.set(0) 
      end
      return true
    end
    
    firstloadScore( )
    resetScore()
    
     local function saveScore( event )
      if event.phase == "ended" then
        score.save()
      end
      return true
    end
  
    local function loadScore( event )
      if event.phase == "ended" then
        local prevScore = score.load()
        if prevScore then
          score.set(prevScore)
        end
      end
      return true
    end
    
    local function highScore(event)
      if event.phase == "ended" then
      local highScore = score.load()
        if score.get() > highScore then
          score.save()
        end
      end
      return true
    end]]--
  end
end

-- "scene:hide()"
function scene:hide( event )

    local sceneGroup = self.view
    local phase = event.phase

    if ( phase == "will" ) then
        -- Called when the scene is on screen (but is about to go off screen).
        -- Insert code here to "pause" the scene.
        -- Example: stop timers, stop animation, stop audio, etc.
        
    elseif ( phase == "did" ) then
        -- Called immediately after scene goes off screen.
        
    end
end


-- "scene:destroy()"
function scene:destroy( event )

    local sceneGroup = self.view

    -- Called prior to the removal of scene's view ("sceneGroup").
    -- Insert code here to clean up the scene.
    -- Example: remove display objects, save state, etc.
    physics.stop()
    transition.cancel()
    Runtime:removeEventListener("enterFrame", move)
    Runtime:removeEventListener("enterFrame", move2)
    Runtime:removeEventListener("enterFrame", move3)
    Runtime:removeEventListener( "enterFrame", main )
    Runtime:removeEventListener("touch", moveAnalog)
    collectgarbage("collect")
end

-- -------------------------------------------------------------------------------

-- Listener setup
scene:addEventListener( "create", scene )
scene:addEventListener( "show", scene )
scene:addEventListener( "hide", scene )
scene:addEventListener( "destroy", scene )

-- -------------------------------------------------------------------------------

return scene