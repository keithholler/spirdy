system.getInfo("model")
display.setStatusBar(display.HiddenStatusBar)

local composer = require( "composer" )
local scene = composer.newScene()

local widget = require( "widget" )
local score = require( "score" )
local music = require("bgMusic")
local physics = require("physics")
local time = require("timer")
local particles = require("particleEffects")
require("mcx")
char = mcx.new()
gems = mcx.new()
charDies = mcx.new()
char:enableDebugging()
gems:enableDebugging()
charDies:enableDebugging()

local centerY = display.contentCenterY
local centerX = display.contentCenterX
local W = display.contentWidth
local H = display.contentHeight
local screenLeft = display.screenOriginX
local screenWidth = display.viewableContentWidth - screenLeft * 2
local screenRight = screenLeft + screenWidth
local screenTop = display.screenOriginY
local screenHeight = display.viewableContentHeight - screenTop * 2
local screenBottom = screenTop + screenHeight
local screenTopSB = screenTop + display.topStatusBarContentHeight
local screenHeightSB = display.viewableContentHeight - screenTopSB
local screenBottomSB = screenTopSB + screenHeightSB

local wall1 = display.newRect( 0, display.contentHeight/2, 2, display.contentHeight )
local wall2 = display.newRect( display.contentWidth/2, 0, display.contentWidth, 2 )
local wall3 = display.newRect( display.contentWidth, display.contentHeight/2, 0, display.contentHeight )
local wall4 = display.newRect( display.contentWidth/2, display.contentHeight , display.contentWidth, 2 )

local scrollSpeed = 0.4
local scrollSpeed2 = 0.8
local gemMove2, gemMove1
local Analog = require("analogStick")
local Text, background, background2, background3, planet1, planet2, planet3, pause

-- Variables for the in-game displays
local gemCounter, coinCounter, coinFont

-- In your sequences, add the parameter 'sheet=', referencing which image sheet the sequence should use
-- local variables for th Gems
local sequenceData = {{ name="Gem1", start=1, count=5, time=800, loopCount=0 }}
local SheetInfo = { width = 40, height = 60, numFrames = 5, sheetContentWidth = 200, sheetContentHeight = 60}
local redSheet = graphics.newImageSheet("redGemsSprites.png", SheetInfo)
local greenSheet = graphics.newImageSheet("greenGemsSprites.png", SheetInfo)

local myGroup = display.newGroup()
local group = {}
local tran, resumeBtn, Player, player1
--physics.setDrawMode( "hybrid" )

-- -----------------------------------------------------------------------------------------------------------------
-- All code outside of the listener functions will only be executed ONCE unless "composer.removeScene()" is called.
-- -----------------------------------------------------------------------------------------------------------------

-- local forward references should go here

-- -------------------------------------------------------------------------------

      --------------------------
      --    Timer Functions   --
      --------------------------
-------------------------------------------------------------------------------------------------------
      function timer:createTimer(delay, listener, iterations)
        local id = null
        id = timer.performWithDelay( delay, listener, iterations )
        table.insert(group,id)
      
        -- Garbage Collection
        if iterations ~= nil and iterations ~= 0 then
          timer.performWithDelay( delay*iterations+100, function(self)
            timer:destroyTimer(id)
          end, 1 )
        end
        return id
      end
      
      -- Find ID of timer in table and destroy it
      function timer:destroyTimer(id)
        for i=1, table.maxn(group), 1 do
          if group[i] == id then
            timer.cancel(id)
            table.remove(group,i)
            return true
          end
        end
          return false
      end
      
      function timer:flushAllTimers()
        for i=table.maxn(group), 1, -1 do
          timer.cancel(group[i])
          table.remove(group,i)
        end
      end
      
      function timer:pauseAllTimers()
        for i=1, table.maxn(group), 1 do
          timer.pause(group[i])
        end
      end
      
      function timer:resumeAllTimers()
        for i=1, table.maxn(group), 1 do
          timer.resume(group[i])
        end
      end 
-------------------------------------------------------------------------------------------------------

local function pause(event)
  local go = event.target.id
  if go == "pause" then
    composer.showOverlay(go, {isModal = true})
    physics.pause()
    transition.pause()
    timer:pauseAllTimers()
    music.atroxOff()
    scrollSpeed = 0
    scrollSpeed2 = 0
    pause.alpha = 0
   end
end

function scene:resume()
   physics.start()
   transition.resume()
   timer:resumeAllTimers()
   music.atroxOn()
   scrollSpeed = .4
   scrollSpeed2 = .8
   pause.alpha = 1
end

scene:addEventListener( "resume", scene )

-- "scene:create()"
function scene:create( event )

    local sceneGroup = self.view
    --local group = display.newGroup()
    --group:insert(sceneGroup)
    
    -- Initialize the scene here.
    -- Example: add display objects to "sceneGroup", add touch listeners, etc.
      sceneGroup:insert(wall1)
      sceneGroup:insert(wall2)
      sceneGroup:insert(wall3)
      sceneGroup:insert(wall4)
      
      physics.start()
      physics.setGravity(0,0)
      music.Atrox()

      -- Create bounding wall for the level
      physics.addBody( wall1, "kinematic", wallMaterial )
      physics.addBody( wall2, "kinematic", wallMaterial )
      physics.addBody( wall3, "kinematic", wallMaterial )
      physics.addBody( wall4, "kinematic", wallMaterial )
        
end

-- "scene:show()"
function scene:show( event )

    local sceneGroup = self.view
    local phase = event.phase
    local group = display.newGroup()
    group:insert(sceneGroup)

    if ( phase == "will" ) then
      -- Called when the scene is still off screen (but is about to come on screen).
      
      ----------------------
      --    Background    --
      ----------------------
-------------------------------------------------------------------------------------------------------

      composer.removeScene("gameOver")
      composer.removeScene("levelSelNorm")
      --score.reset()
      
      Text = display.newText( " ", W*.6, H-20, native.systemFont, 15 )
      background =  display.newImageRect("level1_p1.png", 712.5, 450)
      background2 =  display.newImageRect("level1_p2.png", 712.5, 450)
      background3 =  display.newImageRect("level1_p3.png", 712.5, 450)
      planet1 =  display.newImageRect("planet1.png", 712.5, 450)
      planet2 =  display.newImageRect("planet2.png", 712.5, 450)
      planet3 =  display.newImageRect("planet3.png", 712.5, 450)

      -- Variables for the in-game displays
      gemCounter = display.newImageRect("gameUI/counter_gem.png", 140, 60)
      coinCounter = display.newImageRect("gameUI/counter_coin.png", 140, 60)
      coinFont = display.newText("1", 0, 0, "Soup Of Justice", 24)
      
      background:scale(1, 1)
      background.anchorX = 0;
      background.anchorY = .5;
      background.x = 0; background.y = H/2;
  
      background2:scale(1, 1)
      background2.anchorX = 0;
      background2.anchorY = 0.5;
      background2.x = 712.5; background2.y = H/2;
  
      background3:scale(1, 1)
      background3.anchorX = 0;
      background3.anchorY = 0.5;
      background3.x = 1425; background3.y = H/2;
  
      planet1:scale(1, 1)
      planet1.anchorX = 0;
      planet1.anchorY = .5;
      planet1.x = 0; planet1.y = H/2;
  
      planet2:scale(1, 1)
      planet2.anchorX = 0;
      planet2.anchorY = 0.5;
      planet2.x = 712.5; planet2.y = H/2;
  
      planet3:scale(1, 1)
      planet3.anchorX = 0;
      planet3.anchorY = 0.5;
      planet3.x = 1425; planet3.y = H/2;

      sceneGroup:insert(background)
      sceneGroup:insert(background2)
      sceneGroup:insert(background3)
      sceneGroup:insert(planet1)
      sceneGroup:insert(planet2)
      sceneGroup:insert(planet3)
  
      coinCounter.x = 210
      coinCounter.y = 29
      coinCounter.alpha = 1
  
      gemCounter.x = 65
      gemCounter.y = 30
      gemCounter.alpha = 1
  
      coinFont:setFillColor( 0, 0, 0 )
      coinFont.anchorX = 0
      coinFont.x = 245
      coinFont.y = 32
      
      sceneGroup:insert(Text)
      sceneGroup:insert(coinCounter)
      sceneGroup:insert(gemCounter)
      sceneGroup:insert(coinFont)

    elseif ( phase == "did" ) then
        -- Called when the scene is now on screen.
        -- Insert code here to make the scene come alive.
        -- Example: start timers, begin animation, play audio, etc.
        
        local function move(event)
  
          background.x = background.x - scrollSpeed
          background2.x = background2.x - scrollSpeed
          background3.x = background3.x - scrollSpeed
        
          if(background.x + background.contentWidth) < -712.5 then
            background:translate(712.5*3, 0)
          end
        
          if(background2.x + background2.contentWidth) < -712.5 then
            background2:translate(712.5*3, 0)
          end
        
          if(background3.x + background3.contentWidth) < -712.5 then
            background3:translate(712.5*3, 0)
          end
        end
  
      Runtime:addEventListener("enterFrame", move)
  
      local function move2(event)
  
        planet1.x = planet1.x - scrollSpeed2
        planet2.x = planet2.x - scrollSpeed2
        planet3.x = planet3.x - scrollSpeed2
          
        if(planet1.x + planet1.contentWidth) < -712.5 then
          planet1:translate(712.5*3, 0)
        end
          
        if(planet2.x + planet2.contentWidth) < -712.5 then
          planet2:translate(712.5*3, 0)
        end
          
        if(planet3.x + planet3.contentWidth) < -712.5 then
          planet3:translate(712.5*3, 0)
        end
      end
  
      Runtime:addEventListener("enterFrame", move2)
      
      -- Set parameters for the Analog stick
      MyStick = Analog.NewStick({x = 55, y = 265, thumbSize = 25, borderSize = 45, 
            snapBackSpeed = .75, R = 255, G = 255, B = 255})
            sceneGroup:insert(MyStick)

      local scoreText = score.init({fontSize = 20, font = "Soup Of Justice", x = 90, y = 32, maxDigits = 5, leadingZeros = false, filename = "scorefile.txt",})
        scoreText:setFillColor(0, 0, 0)
        sceneGroup:insert(scoreText)
      
-------------------------------------------------------------------------------------------------------

    ----------------
    --    Gems    --
    ----------------
-------------------------------------------------------------------------------------------------------

    
    local function genGems()
      local gems = {redSheet, greenSheet}
      local gemRan = gems[math.random(#gems)];
      local gemPhysData = (require "blueGem01").physicsData(1.0)
      
      gem = display.newSprite( gemRan, sequenceData );
  
      gem.Gems = gemRan
        
      physics.addBody( gem, "kinematic", gemPhysData:get("blueGem01"))
      
      gem.y = 1 + math.random( 450 ) 
      gem.x = 800
      gem:setSequence( "Gem1" )
      
      gem.type = "gems1"
      gem.value = 1
      gem:play()
      local function handleOnComplete(target)
             target:removeSelf()
             target = nil
      end
      
        transition.to(gem,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
        sceneGroup:insert(gem)
        
        -- After a short time, swap the sequence to 'seq2' which uses the second image sheet
        local function swapSheet()
               gem:setSequence( "Gem1" )
               gem:play()
        end
    end

-------------------------------------------------------------------------------------------------------

    --------------------
    --    Obstacles   --
    --------------------
-------------------------------------------------------------------------------------------------------

    -- Calls obstacles from table and randomly generates them into level 1
    local function obstacles()
      local function handleOnComplete(target)
         target:removeSelf()
         target = nil
      end
      
      local obs = {"obstacle5", "obstacle4", "obstacle6", "obstacle2", "obstacle1"}
      local random = obs[math.random(#obs)];
      local physicsData = (require "level1Obst").physicsData(1.0)

      local function ranGen()
        if random == "obstacle6" then
          
          objObst3 = display.newImage(random..".png");
      
          objObst3.Asteroids = random
      
          physics.addBody( objObst3, "kinematic", physicsData:get(random))
      
          objObst3.x = 1000
          objObst3.y = 200
          objObst3.type = "op1"
          
          transition.to(objObst3,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
          sceneGroup:insert(objObst3)
          
          local function obst6Rotate()
            transition.to(objObst3,{time = 2500,rotation = objObst3.rotation-360, onComplete = obst6Rotate, tag = "transTag"})
          end
            obst6Rotate()
          
          else
            obj = display.newImage(random..".png");
            
            obj.Asteroids = random
            
            physics.addBody( obj, "kinematic", physicsData:get(random))
            
            obj.x = 1000
            obj.y = 200
            obj.type = "op1"
            
            transition.to(obj,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
            sceneGroup:insert(obj)
        end
      end
      
      ranGen()

    end
    
    timer:createTimer(2500, obstacles, 99999)
    timer:createTimer( math.random(1000,4000), genGems, 99999)
-------------------------------------------------------------------------------------------------------

    pause = widget.newButton
    {
       width = 40,
       height = 40,
       defaultFile = "pause.png",
       id = "pause",
       onRelease = pause
    }
    
    pause.x = 650
    pause.y = 30
    pause.alpha = 0.7
    sceneGroup:insert(pause)
    
    -- Spirdy collision function can add more to function if needed
     function collision(self, event)
      if event.phase == "began" then 
--Collision with asteroids
        if self.type == "player"  and event.other.type == "op1" or event.other.type == "op2" or event.other.type == "op3" or event.other.type == "op4"or event.other.type == "op5" then
          local function trans()
           composer.gotoScene("gameOver")
          end
          
          if char:currentAnimation() == "back" or char:currentAnimation() == "up" or char:currentAnimation() == "down" or
          char:currentAnimation() == "forward" or char:currentAnimation() == "idle" then
            Runtime:removeEventListener("enterFrame", move)
            Runtime:removeEventListener("enterFrame", move2)
            Runtime:removeEventListener( "enterFrame", main )
            Runtime:removeEventListener("touch", moveAnalog)
            --physics.stop()
            transition.cancel("transTag")
            timer:pauseAllTimers()
            music.remove()
            char:stop()
            charDies:play({name = "dead"})
            transition.to(charDies, {delay = 1000, onComplete = trans})
           end
-- Collision with gems 
        elseif self.type == "player" and event.other.type == "gems1" or event.other.type == "gems2" then
          score.add(event.other.value)
          event.other.alpha = 0
--Makes the type not equal so the collision is not dected this is to keep the collision at 1
          if event.other.type =="gems1" or event.other.type == "gems2" then
            event.other.type = "none"
         end
        end
      end
    end

    -- Listens for the Analog stick
    function moveAnalog(e)
        if e.phase == "began" then
          MyStick.x = e.x
          MyStick.y = e.y
          e.target = MyStick.Thumb
          e.phase = "began"
          MyStick.onDrag(e)

        elseif e.phase == "moved" then
          timer.createTimer(0, transition.cancel(tapAnalog))
      end  
    end

    Runtime:addEventListener("touch", moveAnalog)
    
    local physicsIdle = (require "idle00").physicsData(1)
    local physicsBack = (require "backwards00").physicsData(1)
    local physicsUp = (require "up00").physicsData(1)
    local physicsDown = (require "down00").physicsData(1)
    local physicsForward = (require "forwards00").physicsData(1)
    
    char:newAnim("idle", 
        mcx.sequence({name = "playerSel/characters/spirdy/idleAnim/idle",
          extension = "png",
          endFrame = 40,
          zeros = 2}),
        57, 86,
        {speed = 0, loops = -1})
        
    char:newAnim("forward", 
        mcx.sequence({name = "playerSel/characters/spirdy/forwardAnim/forwards",
          extension = "png",
          endFrame = 40,
          zeros = 2}),
        62, 85,
        {speed = 0, loops = -1})
        
    char:newAnim("back", 
        mcx.sequence({name = "playerSel/characters/spirdy/backAnim/backwards",
          extension = "png",
          endFrame = 40,
          zeros = 2}),
        68, 85,
        {speed = 0, loops = -1})
        
    char:newAnim("up", 
        mcx.sequence({name = "playerSel/characters/spirdy/upAnim/up",
          extension = "png",
          endFrame = 40,
          zeros = 2}),
        55, 86,
        {speed = 0, loops = -1})
        
    char:newAnim("down", 
        mcx.sequence({name = "playerSel/characters/spirdy/downAnim/down",
          extension = "png",
          endFrame = 40,
          zeros = 2}),
        67, 87,
        {speed = 0, loops = -1})
        
    charDies:newAnim("dead", 
        mcx.sequence({name = "playerSel/characters/spirdy/gameOverAnim/dies",
          extension = "png",
          startFrame = 30,
          endFrame = 104,
          zeros = 3}),
        351, 330,
        {speed = 0, loops = 1})
        
    local player = display.newGroup()
    
    char.x = W*.5
    char.y = H*.5
    charDies.x = W*.5
    charDies.y = H*.5
    -- Sets player to a type object for collision listener
    char.type = "player"
    char.collision = collision 
    char:addEventListener( "collision", char )
    --physics.addBody( char, "dynamic", { density=0, friction=0.0, bounce=0.0 } )
    physics.addBody(char, "dynamic", physicsIdle:get("idle00") )
    char:play({name = "idle"})
    char.isFixedRotation = true
    charDies.isFixedRotation = true

    player:insert(char)
    player:insert(charDies)
    
    sceneGroup:insert(player)
    -- Moves Spirdy around the level
    function main( event )
    -- moves both the sprite sheet (bird1) and the physics image (spirdy)
        MyStick:move(char, 8.0, false)
        MyStick:move(charDies, 8.0, false)
    -- MOST IMPORTANT PART MAKES BIRD1 STICK TO SPIRDY EVEN IF THE PHYSICS HITS A WALL
    -- MAKING THE SPRITE SHEET NOT FLY OFF THE SCREEN
    -- Makes spirdy move forward depending on angle
          if MyStick:getAngle()>= 45 and MyStick:getAngle()<= 135 and char:currentAnimation() == "up" or MyStick:getAngle()>= 45 and MyStick:getAngle()<= 135 and char:currentAnimation() == "down" or
          MyStick:getAngle()>= 45 and MyStick:getAngle()<= 135 and char:currentAnimation() == "back" or MyStick:getAngle()>= 45 and MyStick:getAngle()<= 135 and char:currentAnimation() == "idle" then
            physics.removeBody(char)
            char:play({name = "forward"})

            physics.addBody(char, "dynamic", physicsForward:get("forwards00") )
            char.isFixedRotation = true
            charDies.isFixedRotation = true
            char.type = "player"
    -- Makes spirdy move backwards depending on angle       
          elseif MyStick:getAngle()>= 225 and MyStick:getAngle()<= 315 and char:currentAnimation() == "up" or MyStick:getAngle()>= 225 and MyStick:getAngle()<= 315 and char:currentAnimation() == "down" or
          MyStick:getAngle()>= 225 and MyStick:getAngle()<= 315 and char:currentAnimation() == "forward" or MyStick:getAngle()>= 225 and MyStick:getAngle()<= 315 and char:currentAnimation() == "idle" then
            physics.removeBody(char)
            char:play({name = "back"})

            physics.addBody(char, "dynamic", physicsBack:get("backwards00") )
            char.isFixedRotation = true
            charDies.isFixedRotation = true
            char.type = "player"
    -- Makes spirdy move upwards depending on angle
          elseif MyStick:getAngle()> 315 and MyStick:getAngle()<= 360 and char:currentAnimation() == "back" or MyStick:getAngle()> 0 and MyStick:getAngle()< 45 and char:currentAnimation() == "back" or
          MyStick:getAngle()> 315 and MyStick:getAngle()<= 360 and char:currentAnimation() == "forward" or MyStick:getAngle()> 0 and MyStick:getAngle()< 45 and char:currentAnimation() == "forward" or
          MyStick:getAngle()> 315 and MyStick:getAngle()<= 360 and char:currentAnimation() == "down" or MyStick:getAngle()> 0 and MyStick:getAngle()< 45 and char:currentAnimation() == "down" or 
          MyStick:getAngle()> 315 and MyStick:getAngle()<= 360 and char:currentAnimation() == "idle" or MyStick:getAngle()> 0 and MyStick:getAngle()< 45 and char:currentAnimation() == "idle" then
            physics.removeBody(char)
            char:play({name = "up"})

            physics.addBody(char, "dynamic", physicsUp:get("up00") )
            char.isFixedRotation = true
            charDies.isFixedRotation = true
            char.type = "player"
    -- Makes spirdy move downwards depending on angle
          elseif MyStick:getAngle()> 135 and MyStick:getAngle()< 225 and char:currentAnimation() == "back" or MyStick:getAngle()> 135 and MyStick:getAngle()< 225 and char:currentAnimation() == "forward" or
          MyStick:getAngle()> 135 and MyStick:getAngle()< 225 and char:currentAnimation() == "up" or MyStick:getAngle()> 135 and MyStick:getAngle()< 225 and char:currentAnimation() == "idle" then
            physics.removeBody(char)
            char:play({name = "down"})

            physics.addBody(char, "dynamic", physicsDown:get("down00") )
            char.isFixedRotation = true
            charDies.isFixedRotation = true
            char.type = "player"
      end
    end
 
    Runtime:addEventListener( "enterFrame", main )
        
     local function saveScore( event )
      if event.phase == "ended" then
        score.save()
      end
      return true
    end
  
    local function loadScore( event )
      if event.phase == "ended" then
        local prevScore = score.load()
        if prevScore then
          score.set(prevScore)
        end
      end
      return true
    end
    
    local function highScore(event)
      if event.phase == "ended" then
      local highScore = score.load()
        if score.get() > highScore then
          score.save()
        end
      end
      return true
    end
    
    local saveButton = widget.newButton({width = 200, height = 64, x = display.contentCenterX, y = display.contentHeight - 32,
      label = "Save Score", labelColor = { default = { 1, 1, 1 }, over = { 0, 0, 0 } },
      fontSize = 32, onEvent = saveScore})
      sceneGroup:insert(saveButton)

    local loadButton = widget.newButton({ width = 200, height = 64, x = display.contentCenterX, y = display.contentHeight - 64,
      label = "Load Score", labelColor = { default = { 1, 1, 1 }, over = { 0, 0, 0 } },
      fontSize = 32, onEvent = loadScore})
      sceneGroup:insert(loadButton)
         
    end
end

-- "scene:hide()"
function scene:hide( event )

    local sceneGroup = self.view
    local phase = event.phase

    if ( phase == "will" ) then
        -- Called when the scene is on screen (but is about to go off screen).
        -- Insert code here to "pause" the scene.
        -- Example: stop timers, stop animation, stop audio, etc.
    elseif ( phase == "did" ) then
        -- Called immediately after scene goes off screen.
    end
end


-- "scene:destroy()"
function scene:destroy( event )

    local sceneGroup = self.view

    -- Called prior to the removal of scene's view ("sceneGroup").
    -- Insert code here to clean up the scene.
    -- Example: remove display objects, save state, etc.
    physics.stop()
                
end

-- -------------------------------------------------------------------------------

-- Listener setup
scene:addEventListener( "create", scene )
scene:addEventListener( "show", scene )
scene:addEventListener( "hide", scene )
scene:addEventListener( "destroy", scene )

-- -------------------------------------------------------------------------------

return scene