system.getInfo("model")
display.setStatusBar(display.HiddenStatusBar)

local composer = require( "composer" )
local scene = composer.newScene()

local widget = require( "widget" )
local score = require( "score" )
local music = require("bgMusic")
local physics = require("physics")
local time = require("timer")
local particles = require("particleDesigner")
--local backGround = require("bgScene")

require("mcx")
char = mcx.new()
gems = mcx.new()
charDies = mcx.new()

char:enableDebugging()
gems:enableDebugging()
charDies:enableDebugging()

local centerY = display.contentCenterY
local centerX = display.contentCenterX
local W = display.contentWidth
local H = display.contentHeight
local screenLeft = display.screenOriginX
local screenWidth = display.viewableContentWidth - screenLeft * 2
local screenRight = screenLeft + screenWidth
local screenTop = display.screenOriginY
local screenHeight = display.viewableContentHeight - screenTop * 2
local screenBottom = screenTop + screenHeight
local screenTopSB = screenTop + display.topStatusBarContentHeight
local screenHeightSB = display.viewableContentHeight - screenTopSB
local screenBottomSB = screenTopSB + screenHeightSB

physics.start()
physics.setGravity(0,0)
physics.setContinuous(true)

local wall1, wall2, wall3, wall4 

local myAnimation, myAnimation2
local scrollSpeed = 0.4
local scrollSpeed2 = 0.8
local gemMove2, gemMove1
local Analog = require("analogStick")
local Text, background, background2, background3, planet1, planet2, planet3, pause

-- Variables for the in-game displays
local gemCounter, coinCounter, coinFont
local op1, op2, op3, op4, op5

-- In your sequences, add the parameter 'sheet=', referencing which image sheet the sequence should use
-- local variables for th Gems
local sequenceData = {{ name="Gem1", start=1, count=5, time=800, loopCount=0 }}
local SheetInfo = { width = 40, height = 60, numFrames = 5, sheetContentWidth = 200, sheetContentHeight = 60}
local redSheet = graphics.newImageSheet("redGemsSprites.png", SheetInfo)
local greenSheet = graphics.newImageSheet("greenGemsSprites.png", SheetInfo)

--local myGroup = display.newGroup()
local group = {}
local tran, resumeBtn, Player, player1
--physics.setDrawMode( "hybrid" )

-- -----------------------------------------------------------------------------------------------------------------
-- All code outside of the listener functions will only be executed ONCE unless "composer.removeScene()" is called.
-- -----------------------------------------------------------------------------------------------------------------

-- local forward references should go here

-- -------------------------------------------------------------------------------

      --------------------------
      --    Timer Functions   --
      --------------------------
-------------------------------------------------------------------------------------------------------
      function timer:createTimer(delay, listener, iterations)
        local id = null
        id = timer.performWithDelay( delay, listener, iterations )
        table.insert(group,id)
      
        -- Garbage Collection
        if iterations ~= nil and iterations ~= 0 then
          timer.performWithDelay( delay*iterations+100, function(self)
            timer:destroyTimer(id)
          end, 1 )
        end
        return id
      end
      
      -- Find ID of timer in table and destroy it
      function timer:destroyTimer(id)
        for i=1, table.maxn(group), 1 do
          if group[i] == id then
            timer.cancel(id)
            table.remove(group,i)
            return true
          end
        end
          return false
      end
      
      function timer:flushAllTimers()
        for i=table.maxn(group), 1, -1 do
          timer.cancel(group[i])
          table.remove(group,i)
        end
      end
      
      function timer:pauseAllTimers()
        for i=1, table.maxn(group), 1 do
          timer.pause(group[i])
        end
      end
      
      function timer:resumeAllTimers()
        for i=1, table.maxn(group), 1 do
          timer.resume(group[i])
        end
      end 
-------------------------------------------------------------------------------------------------------

local function pause(event)
  local go = event.target.id
  if go == "pause" then
    composer.showOverlay(go, {isModal = true})
    physics.pause()
    transition.pause()
    timer:pauseAllTimers()
    music.atroxOff()
    scrollSpeed = 0
    scrollSpeed2 = 0
    pause.alpha = 0
   end
end

function scene:resume()
   physics.start()
   transition.resume()
   timer:resumeAllTimers()
   music.atroxOn()
   scrollSpeed = .4
   scrollSpeed2 = .8
   pause.alpha = 1
end

scene:addEventListener( "resume", scene )

-- "scene:create()"
function scene:create( event )

    local sceneGroup = self.view
    --local group = display.newGroup()
    --group:insert(sceneGroup)
    
    -- Initialize the scene here.
    -- Example: add display objects to "sceneGroup", add touch listeners, etc.
      wall1 = display.newRect(sceneGroup, 0, display.contentHeight/2, 2, display.contentHeight )
      wall2 = display.newRect(sceneGroup, display.contentWidth/2, 0, display.contentWidth, 2 )
      wall3 = display.newRect(sceneGroup, display.contentWidth, display.contentHeight/2, 0, display.contentHeight )
      wall4 = display.newRect(sceneGroup, display.contentWidth/2, display.contentHeight , display.contentWidth, 2 )

      -- Create bounding wall for the level
      physics.addBody( wall1, "kinematic", wallMaterial )
      physics.addBody( wall2, "kinematic", wallMaterial )
      physics.addBody( wall3, "kinematic", wallMaterial )
      physics.addBody( wall4, "kinematic", wallMaterial )
      
      ----------------------
      --    Background/UI    --
      ----------------------
-------------------------------------------------------------------------------------------------------
      Text = display.newText(sceneGroup, " ", W*.6, H-20, native.systemFont, 15 )
      background =  display.newImageRect(sceneGroup, "levels/backgrounds/level1/bg1Part1.png", 712.5, 450)
      background2 =  display.newImageRect(sceneGroup, "levels/backgrounds/level1/bg1Part2.png", 712.5, 450)
      background3 =  display.newImageRect(sceneGroup, "levels/backgrounds/level1/bg1Part3.png", 712.5, 450)
      planet1 =  display.newImageRect(sceneGroup, "levels/backgrounds/level1/lay1Part1.png", 712.5, 450)
      planet2 =  display.newImageRect(sceneGroup, "levels/backgrounds/level1/lay1Part2.png", 712.5, 450)
      planet3 =  display.newImageRect(sceneGroup, "levels/backgrounds/level1/lay1Part3.png", 712.5, 450)

      -- Variables for the in-game displays
      gemCounter = display.newImageRect(sceneGroup, "gameUI/counter_gem.png", 140, 60)
      coinCounter = display.newImageRect(sceneGroup, "gameUI/counter_coin.png", 140, 60)
      coinFont = display.newText(sceneGroup, "1", 0, 0, "Soup Of Justice", 24)
      
      background:scale(1, 1)
      background.anchorX = 0;
      background.anchorY = .5;
      background.x = 0; background.y = H/2;
  
      background2:scale(1, 1)
      background2.anchorX = 0;
      background2.anchorY = 0.5;
      background2.x = 712.5; background2.y = H/2;
  
      background3:scale(1, 1)
      background3.anchorX = 0;
      background3.anchorY = 0.5;
      background3.x = 1425; background3.y = H/2;
  
      planet1:scale(1, 1)
      planet1.anchorX = 0;
      planet1.anchorY = .5;
      planet1.x = 0; planet1.y = H/2;
  
      planet2:scale(1, 1)
      planet2.anchorX = 0;
      planet2.anchorY = 0.5;
      planet2.x = 712.5; planet2.y = H/2;
  
      planet3:scale(1, 1)
      planet3.anchorX = 0;
      planet3.anchorY = 0.5;
      planet3.x = 1425; planet3.y = H/2;
  
      coinCounter.x = 210
      coinCounter.y = 29
      coinCounter.alpha = 1
  
      gemCounter.x = 65
      gemCounter.y = 30
      gemCounter.alpha = 1
  
      coinFont:setFillColor( 0, 0, 0 )
      coinFont.anchorX = 0
      coinFont.x = 245
      coinFont.y = 32
end

-- "scene:show()"
function scene:show( event )

    local sceneGroup = self.view
    local phase = event.phase

    if ( phase == "will" ) then
      -- Called when the scene is still off screen (but is about to come on screen).

      --backGround.removeBg()
      composer.removeScene("gameOver")
      composer.removeScene("levelSelNorm")
      --score.reset()
      
        music.Atrox()
        function move(event)
  
          background.x = background.x - scrollSpeed
          background2.x = background2.x - scrollSpeed
          background3.x = background3.x - scrollSpeed
        
          if(background.x + background.contentWidth) < -712.5 then
            background:translate(712.5*3, 0)
          end
        
          if(background2.x + background2.contentWidth) < -712.5 then
            background2:translate(712.5*3, 0)
          end
        
          if(background3.x + background3.contentWidth) < -712.5 then
            background3:translate(712.5*3, 0)
          end
        end
  
      Runtime:addEventListener("enterFrame", move)
  
      function move2(event)
  
        planet1.x = planet1.x - scrollSpeed2
        planet2.x = planet2.x - scrollSpeed2
        planet3.x = planet3.x - scrollSpeed2
          
        if(planet1.x + planet1.contentWidth) < -712.5 then
          planet1:translate(712.5*3, 0)
        end
          
        if(planet2.x + planet2.contentWidth) < -712.5 then
          planet2:translate(712.5*3, 0)
        end
          
        if(planet3.x + planet3.contentWidth) < -712.5 then
          planet3:translate(712.5*3, 0)
        end
      end
  
      Runtime:addEventListener("enterFrame", move2)
      
    elseif ( phase == "did" ) then
        -- Called when the scene is now on screen.
        -- Insert code here to make the scene come alive.
        -- Example: start timers, begin animation, play audio, etc.
        
      -- Set parameters for the Analog stick
      MyStick = Analog.NewStick({x = 55, y = 265, thumbSize = 25, borderSize = 45, 
            snapBackSpeed = .75, R = 255, G = 255, B = 255})
            sceneGroup:insert(MyStick)

      local scoreText = score.init({fontSize = 20, font = "Soup Of Justice", x = 90, y = 32, maxDigits = 5, leadingZeros = false, filename = "scorefile.txt",})
        scoreText:setFillColor(0, 0, 0)
        sceneGroup:insert(scoreText)
      
-------------------------------------------------------------------------------------------------------

    ----------------
    --    Gems    --
    ----------------
-------------------------------------------------------------------------------------------------------

    
    local function genGems()
      local gems = {redSheet, greenSheet}
      local gemRan = gems[math.random(#gems)];
      local gemPhysData = (require "blueGem01").physicsData(1.0)
      
      gem = display.newSprite(sceneGroup, gemRan, sequenceData );
  
      gem.Gems = gemRan
        
      physics.addBody( gem, "kinematic", gemPhysData:get("blueGem01"))
      
      gem.y = 1 + math.random( 450 ) 
      gem.x = 800
      gem:setSequence( "Gem1" )
      
      gem.type = "gems1"
      gem.value = 1
      gem:play()
      local function handleOnComplete(target)
             target:removeSelf()
             target = nil
      end
      
        transition.to(gem,{time = 4500,x=(W-900), onComplete = handleOnComplete, tag = "transTag"})
        --sceneGroup:insert(gem)
        
        -- After a short time, swap the sequence to 'seq2' which uses the second image sheet
        local function swapSheet()
               gem:setSequence( "Gem1" )
               gem:play()
        end
    end
    
    --[[local gemMove1 = function()
      local function handleOnComplete(target)
           target:removeSelf()
           target = nil
      end

        myAnimation = display.newSprite( redSheet, sequenceData )
        myAnimation.y = 1 + math.random( 450 ); myAnimation.x = 800
        physics.addBody(myAnimation, "kinematic", {isSensor = true})
        transition.to(myAnimation,{time = math.random(6000,25000),x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
        myAnimation:setSequence( "Gem1" )
        myAnimation:play()
        myAnimation.type = "gems1"
        myAnimation.value = 1
        sceneGroup:insert(myAnimation)
    end 
    
    local gemMove2 = function()
      local function handleOnComplete(target)
           target:removeSelf()
           target = nil
      end

        myAnimation2 = display.newSprite( greenSheet, sequenceData )
        myAnimation2.y = 1 + math.random( 450 ); myAnimation2.x = 800
        physics.addBody(myAnimation2, "kinematic", {isSensor = true})
        transition.to(myAnimation2,{time = math.random(6000,25000),x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
        myAnimation2:setSequence( "Gem1" )
        myAnimation2:play()
        myAnimation2.type = "gems2"
        myAnimation2.value = 1
        sceneGroup:insert(myAnimation2)
    end]]--

-------------------------------------------------------------------------------------------------------

    --------------------
    --    Obstacles   --
    --------------------
-------------------------------------------------------------------------------------------------------

    -- Calls obstacles from table and randomly generates them into level 1
    --[[local function obstacles()
      local function handleOnComplete(target)
         target:removeSelf()
         target = nil
      end
      
      local obs = {{filename = "normalMode/level1/obstacle5", width = 598, height = 450, tag = "obstacle5"}, {filename = "normalMode/level1/obstacle4", width = 562, height = 450, tag = "obstacle4"},
       {filename = "normalMode/level1/obstacle6", width = 379, height = 396, tag = "obstacle6"}, {filename = "normalMode/level1/obstacle2", width = 478, height = 450, tag = "obstacle2"}, 
       {filename = "normalMode/level1/obstacle1", width = 491, height = 450, tag = "obstacle1"}}
      --local random = obs[math.random(#obs)];
      local index = math.random(#obs)
      local obstacle = obs[index]
      local physicsData = (require "normalMode.level1.level1Obst").physicsData(1.0)

      local function ranGen()
        if obstacle.filename == "normalMode/level1/obstacle1" or obstacle.filename == "normalMode/level1/obstacle2" or obstacle.filename == "normalMode/level1/obstacle4" or
        obstacle.filename == "normalMode/level1/obstacle5" then
        
          obj = display.newImageRect(sceneGroup, obstacle.filename..".png", obstacle.width, obstacle.height);
            
            obj.Asteroids = obstacle
            
            physics.addBody( obj, "kinematic", physicsData:get(obstacle.tag))
            
            obj.x = 1000
            obj.y = 200
            obj.type = "op1"
            
            transition.to(obj,{time = 5000,x=(W-1000), onComplete = handleOnComplete, tag = "transTag"})
            --sceneGroup:insert(obj)

          else
            objObst3 = display.newImageRect(sceneGroup, obstacle.filename..".png", obstacle.width, obstacle.height);
            
            objObst3.Asteroids = obstacle
        
            physics.addBody( objObst3, "kinematic", physicsData:get(obstacle.tag))
        
            objObst3.x = 1000
            objObst3.y = 200
            objObst3.type = "op1"
  
            transition.to(objObst3,{time = 5000, x=(W-1000), onComplete = handleOnComplete, tag = "transTag"})
            --sceneGroup:insert(objObst3)
            
            local function obst6Rotate()
              transition.to(objObst3,{time = 2500,rotation = objObst3.rotation-360, onComplete = obst6Rotate, tag = "transTag"})
            end
            
            obst6Rotate()
            
        end
      end
      
      ranGen()

    end]]--
    local physicsData = (require "levels.normalMode.level1.level1Physics").physicsData(1.0)
    
    local opMove5 = function()
        local function handleOnComplete(target)
           target:removeSelf()
           target = nil
        end
      
        --local physicsData = (require "obstacle_5").physicsData(1)
        op5 = display.newImageRect("levels/normalMode/level1/obstacle5.png",598,450)
        
        physics.addBody(op5, "kinematic", physicsData:get("obstacle5") )
        op5.x = 1000
        op5.y = 200
        op5.type = "obstacle"
        sceneGroup:insert(op5)
      
        transition.to(op5,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
    end

    --[[local opMove4 = function()
      local function handleOnComplete(target)
           target:removeSelf()
           target = nil
      end
      
      --local physicsData = (require "obstacle_4").physicsData(1)
      local op4 = display.newImageRect("levels/normalMode/level1/obstacle4.png",562,450)

      physics.addBody(op4, "kinematic", physicsData:get("obstacle4") )
      op4.x = 1000
      op4.y = 200
      op4.type = "op1"
      sceneGroup:insert(op4)
      
      transition.to(op4,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
    end]]--

    local opMove3 = function()
        local function handleOnComplete(target)
           target:removeSelf()
           target = nil
        end
      
        --local physicsData = (require "L1_Cshape_crop").physicsData(1)
        local op3 = display.newImageRect("levels/normalMode/level1/obstacle6.png",379,396)
      
        physics.addBody(op3, "kinematic", physicsData:get("obstacle6") )
        op3.rotation = 400
        op3.x = 1000
        op3.y = 175
        op3.type = "obstacle"
        sceneGroup:insert(op3)
        
        transition.to(op3,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
        
        local function Lshaperotate()
          transition.to(op3,{time = 2500,rotation = op3.rotation-360, onComplete = Lshaperotate, tag = "transTag"})
        end
        
        Lshaperotate()
    end

    local opMove2 = function()
        local function handleOnComplete(target)
           target:removeSelf()
           target = nil
        end

        --local physicsData = (require "obstacle_2").physicsData(1)
        local op2 = display.newImageRect("levels/normalMode/level1/obstacle2.png",478,450)

        physics.addBody(op2, "kinematic", physicsData:get("obstacle2") )
        op2.x = 1000
        op2.y = 200
        op2.type = "obstacle"
        sceneGroup:insert(op2)
      
        transition.to(op2,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
    end

    local opMove1 = function()
        local function handleOnComplete(target)
           target:removeSelf()
           target = nil
        end

        --local physicsData = (require "obstacle_1").physicsData(1)
        local op1 = display.newImageRect("levels/normalMode/level1/obstacle1.png",491,450)
      
        physics.addBody(op1, "kinematic", physicsData:get("obstacle1") )
        op1.x = 1000
        op1.y = 200
        op1.type = "obstacle"
        sceneGroup:insert(op1)
      
        transition.to(op1,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
    end
    
    local opMove4 = function()
        local function handleOnComplete(target)
           target:removeSelf()
           target = nil
        end

        --local physicsData = (require "obstacle_1").physicsData(1)
        local op4 = display.newImageRect("levels/normalMode/level1/obstacle3.png",663,450)
        local op6C = display.newImageRect("levels/normalMode/level1/obstacle6.png",379,396) 
        
        physics.addBody(op4, "kinematic", physicsData:get("obstacle3") )
        op4.x = 1000
        op4.y = 200
        op4.type = "obstacle"
        sceneGroup:insert(op4)
        
        physics.addBody(op6C, "kinematic", physicsData:get("obstacle6") )
        op6C.x = 1000
        op6C.y = 200
        op6C.type = "obstacle"
        sceneGroup:insert(op6C)
      
        transition.to(op6C,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
      
        transition.to(op4,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
        
        local function cRotate()
          transition.to(op6C,{time = 2500,rotation = op6C.rotation-360, onComplete = cRotate, tag = "transTag"})
        end
        
        cRotate()
    end
    
    local opMove6 = function()
        local function handleOnComplete(target)
           target:removeSelf()
           target = nil
        end

        --local physicsData = (require "obstacle_1").physicsData(1)
        local op6 = display.newImageRect("levels/normalMode/level1/ob_1.png",490,450)
      
        physics.addBody(op6, "kinematic", physicsData:get("ob_1") )
        op6.x = 1000
        op6.y = 200
        op6.type = "obstacle"
        sceneGroup:insert(op6)
      
        transition.to(op6,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
    end
    
    local opMove7 = function()
        local function handleOnComplete(target)
           target:removeSelf()
           target = nil
        end

        --local physicsData = (require "obstacle_1").physicsData(1)
        local op7 = display.newImageRect("levels/normalMode/level1/ob_2.png",691,441)
      
        physics.addBody(op7, "kinematic", physicsData:get("ob_2") )
        op7.x = 1000
        op7.y = 200
        op7.type = "obstacle"
        sceneGroup:insert(op7)
      
        transition.to(op7,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
    end
    
    local opMove8 = function()
        local function handleOnComplete(target)
           target:removeSelf()
           target = nil
        end

        --local physicsData = (require "obstacle_1").physicsData(1)
        local op8 = display.newImageRect("levels/normalMode/level1/ob_3.png",547,436)
      
        physics.addBody(op8, "kinematic", physicsData:get("ob_3") )
        op8.x = 1000
        op8.y = 200
        op8.type = "obstacle"
        sceneGroup:insert(op8)
      
        transition.to(op8,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
    end
    
    local opMove9 = function()
        local function handleOnComplete(target)
           target:removeSelf()
           target = nil
        end

        --local physicsData = (require "obstacle_1").physicsData(1)
        local op9 = display.newImageRect("levels/normalMode/level1/ob_5.png",595,450)
      
        physics.addBody(op9, "kinematic", physicsData:get("ob_5") )
        op9.x = 1000
        op9.y = 200
        op9.type = "obstacle"
        sceneGroup:insert(op9)
      
        transition.to(op9,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
    end
    
    local opMove10 = function()
        local function handleOnComplete(target)
           target:removeSelf()
           target = nil
        end

        --local physicsData = (require "obstacle_1").physicsData(1)
        local op10 = display.newImageRect("levels/normalMode/level1/ob_6.png",412,450)
      
        physics.addBody(op10, "kinematic", physicsData:get("ob_6") )
        op10.x = 1100
        op10.y = 200
        op10.type = "obstacle"
        sceneGroup:insert(op10)
      
        transition.to(op10,{time = 10000,x=(W-2000), onComplete = handleOnComplete, tag = "transTag"})
    end

    local pick = function()
      Object = math.ceil(math.random(1,10))
      if Object == 1 then opMove1()  
      elseif Object == 2 then opMove2()
      elseif Object == 3 then opMove3()
      elseif Object == 4 then opMove4()  
      elseif Object == 5 then opMove5()
      elseif Object == 6 then opMove6()
      elseif Object == 7 then opMove7()
      elseif Object == 8 then opMove8()
      elseif Object == 9 then opMove9()
      elseif Object == 10 then opMove10()
      end
    end
    
    --timer:createTimer(2500, obstacles, 99999)
    timer:createTimer(2500, pick, 99999)
    --timer:createTimer( math.random(1000,4000), gemMove1, 99999)
    --timer:createTimer( math.random(1000,4000), gemMove2, 99999)
    timer:createTimer( math.random(1000,4000), genGems, 99999)
-------------------------------------------------------------------------------------------------------

    pause = widget.newButton
    {
       width = 40,
       height = 40,
       defaultFile = "pause.png",
       id = "pause",
       onRelease = pause
    }
    
    pause.x = 650
    pause.y = 30
    pause.alpha = 0.7
    sceneGroup:insert(pause)
    
     -- Spirdy collision function can add more to function if needed
     function collision(self, event)
      if event.phase == "began" then 
        --Collision with asteroids
        if self.type == "player"  and event.other.type == "obstacle" then
          local function trans()
           gem:removeSelf()
           gem = nil
           pause:removeSelf()
           pause = nil
           scoreText:removeSelf()
           scoreText = nil
           gemCounter:removeSelf()
           gemCounter = nil
           coinCounter:removeSelf()
           coinCounter = nil
           composer.showOverlay("gameOver")
          end
            --highsaveScore()
          if char:currentAnimation() == "back" or char:currentAnimation() == "up" or char:currentAnimation() == "down" or
          char:currentAnimation() == "forward" or char:currentAnimation() == "idle" then
            Runtime:removeEventListener("enterFrame", move)
            Runtime:removeEventListener("enterFrame", move2)
            Runtime:removeEventListener( "enterFrame", main )
            Runtime:removeEventListener("touch", moveAnalog)
            --physics.stop()
            transition.cancel("transTag")
            timer:pauseAllTimers()
            music.remove()
            
            charDies:newAnim("dead", 
              mcx.sequence({name = "playerSel/characters/spirdy/gameOverAnim/dies",
              extension = "png",
              endFrame = 24,
              zeros = 2}),
            351, 330,
            {speed = 1, loops = 1})
            
            char:stop()
            
            charDies:play({name = "dead"})
            transition.to(charDies, {delay = 1000, onComplete = trans})
           end
-- Collision with gems 
        elseif self.type == "player" and event.other.type == "gems1" or event.other.type == "gems2" then
          score.add(event.other.value)
          event.other.alpha = 0
--Makes the type not equal so the collision is not dected this is to keep the collision at 1
          if event.other.type =="gems1" or event.other.type == "gems2" then
            event.other.type = "none"
         end
        end
      end
    end

    -- Listens for the Analog stick
    function moveAnalog(e)
        if e.phase == "began" then
          MyStick.x = e.x
          MyStick.y = e.y
          e.target = MyStick.Thumb
          e.phase = "began"
          MyStick.onDrag(e)

        elseif e.phase == "moved" then
          timer.createTimer(0, transition.cancel(tapAnalog))
      end  
    end

    Runtime:addEventListener("touch", moveAnalog)
    
    local physicsIdle = (require "idle00").physicsData(1)
    local physicsBack = (require "backwards00").physicsData(1)
    local physicsUp = (require "up00").physicsData(1)
    local physicsDown = (require "down00").physicsData(1)
    local physicsForward = (require "forwards00").physicsData(1)
    
    char:newAnim("idle", 
        mcx.sequence({name = "playerSel/characters/spirdy/idleAnim/idle",
          extension = "png",
          endFrame = 10,
          zeros = 2}),
        57, 86,
        {speed = 2, loops = -1})
        
    char:newAnim("forward", 
        mcx.sequence({name = "playerSel/characters/spirdy/forwardAnim/fwd",
          extension = "png",
          endFrame = 8,
          zeros = 2}),
        62, 84,
        {speed = 2, loops = -1})
        
    char:newAnim("back", 
        mcx.sequence({name = "playerSel/characters/spirdy/backAnim/back",
          extension = "png",
          endFrame = 8,
          zeros = 2}),
        68, 84,
        {speed = 2, loops = -1})
        
    char:newAnim("up", 
        mcx.sequence({name = "playerSel/characters/spirdy/upAnim/up",
          extension = "png",
          endFrame = 8,
          zeros = 2}),
        55, 85,
        {speed = 2, loops = -1})
        
    char:newAnim("down", 
        mcx.sequence({name = "playerSel/characters/spirdy/downAnim/down",
          extension = "png",
          endFrame = 8,
          zeros = 2}),
        66, 85,
        {speed = 2, loops = -1})
        
    local player = display.newGroup()
    
    char.x = W*.5
    char.y = H*.5
    charDies.x = W*.5
    charDies.y = H*.5
    -- Sets player to a type object for collision listener
    char.type = "player"
    char.collision = collision 
    char:addEventListener( "collision", char )
    --physics.addBody( char, "dynamic", { density=0, friction=0.0, bounce=0.0 } )
    physics.addBody(char, "dynamic", physicsIdle:get("idle00") )
    char:play({name = "idle"})
    char.isFixedRotation = true
    charDies.isFixedRotation = true
    
    sceneGroup:insert(char)
    sceneGroup:insert(charDies)
    
    -- Moves Spirdy around the level
    function main( event )
    -- moves both the sprite sheet (bird1) and the physics image (spirdy)
        MyStick:move(char, 6.0, false)
        MyStick:move(charDies, 6.0, false)
    -- MOST IMPORTANT PART MAKES BIRD1 STICK TO SPIRDY EVEN IF THE PHYSICS HITS A WALL
    -- MAKING THE SPRITE SHEET NOT FLY OFF THE SCREEN
    -- Makes spirdy move forward depending on angle
          if MyStick:getAngle()>= 45 and MyStick:getAngle()<= 135 and char:currentAnimation() == "up" or MyStick:getAngle()>= 45 and MyStick:getAngle()<= 135 and char:currentAnimation() == "down" or
          MyStick:getAngle()>= 45 and MyStick:getAngle()<= 135 and char:currentAnimation() == "back" or MyStick:getAngle()>= 45 and MyStick:getAngle()<= 135 and char:currentAnimation() == "idle" then
            physics.removeBody(char)
            char:play({name = "forward"})

            physics.addBody(char, "dynamic", physicsForward:get("forwards00") )
            char.isFixedRotation = true
            --charDies.isFixedRotation = true
            char.type = "player"
    -- Makes spirdy move backwards depending on angle       
          elseif MyStick:getAngle()>= 225 and MyStick:getAngle()<= 315 and char:currentAnimation() == "up" or MyStick:getAngle()>= 225 and MyStick:getAngle()<= 315 and char:currentAnimation() == "down" or
          MyStick:getAngle()>= 225 and MyStick:getAngle()<= 315 and char:currentAnimation() == "forward" or MyStick:getAngle()>= 225 and MyStick:getAngle()<= 315 and char:currentAnimation() == "idle" then
            physics.removeBody(char)
            char:play({name = "back"})

            physics.addBody(char, "dynamic", physicsBack:get("backwards00") )
            char.isFixedRotation = true
            --charDies.isFixedRotation = true
            char.type = "player"
    -- Makes spirdy move upwards depending on angle
          elseif MyStick:getAngle()> 315 and MyStick:getAngle()<= 360 and char:currentAnimation() == "back" or MyStick:getAngle()> 0 and MyStick:getAngle()< 45 and char:currentAnimation() == "back" or
          MyStick:getAngle()> 315 and MyStick:getAngle()<= 360 and char:currentAnimation() == "forward" or MyStick:getAngle()> 0 and MyStick:getAngle()< 45 and char:currentAnimation() == "forward" or
          MyStick:getAngle()> 315 and MyStick:getAngle()<= 360 and char:currentAnimation() == "down" or MyStick:getAngle()> 0 and MyStick:getAngle()< 45 and char:currentAnimation() == "down" or 
          MyStick:getAngle()> 315 and MyStick:getAngle()<= 360 and char:currentAnimation() == "idle" or MyStick:getAngle()> 0 and MyStick:getAngle()< 45 and char:currentAnimation() == "idle" then
            physics.removeBody(char)
            char:play({name = "up"})

            physics.addBody(char, "dynamic", physicsUp:get("up00") )
            char.isFixedRotation = true
            --charDies.isFixedRotation = true
            char.type = "player"
    -- Makes spirdy move downwards depending on angle
          elseif MyStick:getAngle()> 135 and MyStick:getAngle()< 225 and char:currentAnimation() == "back" or MyStick:getAngle()> 135 and MyStick:getAngle()< 225 and char:currentAnimation() == "forward" or
          MyStick:getAngle()> 135 and MyStick:getAngle()< 225 and char:currentAnimation() == "up" or MyStick:getAngle()> 135 and MyStick:getAngle()< 225 and char:currentAnimation() == "idle" then
            physics.removeBody(char)
            char:play({name = "down"})

            physics.addBody(char, "dynamic", physicsDown:get("down00") )
            char.isFixedRotation = true
            --charDies.isFixedRotation = true
            char.type = "player"
      end
    end
 
    Runtime:addEventListener( "enterFrame", main )

    -- Collides with the Red gem and adds to the counter
    --[[local function onCollision(event)
      if event.phase == "began" then
       local player = event.object1
       local gem1 = event.object2
         
        if player.type == "player" and gem1.type == "gems1" then
          score.add(event.object2.value)
          event.object2.alpha = 0
        end
      end
    end

    Runtime:addEventListener("collision", onCollision)

    -- Collides with the Gree gem and adds to the counter
    local function onCollision2(event)
      if event.phase == "began" then
       local player = event.object1
       local gem2 = event.object2
         
        if player.type == "player" and gem2.type == "gems2" then
          score.add(event.object2.value)
          event.object2.alpha = 0
        end
      end
    end
         
    Runtime:addEventListener("collision", onCollision2)
    
    -- Collision for obstacle3
     local function onCollision3(event)
      if event.phase == "began" then
       local player = event.object1
       local op3 = event.object2
        if player.type == "player" and op3.type == "op3" then

          local function trans()
           --composer.gotoScene("gameOver")
          end
          
          if char:currentAnimation() == "back" or char:currentAnimation() == "up" or char:currentAnimation() == "down" or
          char:currentAnimation() == "forward" or char:currentAnimation() == "idle" then
            Runtime:removeEventListener("enterFrame", move)
            Runtime:removeEventListener("enterFrame", move2)
            Runtime:removeEventListener( "enterFrame", main )
            Runtime:removeEventListener("touch", moveAnalog)
            --physics.stop()
            transition.cancel("transTag")
            timer:pauseAllTimers()
            music.remove()
            char:stop()
            charDies:play({name = "dead"})
            transition.to(charDies, {onComplete = trans})
          end

           --transition.to(char, {onComplete = playDeath})
           --score.save()
        end
      end
    end
    
    Runtime:addEventListener("collision", onCollision3)
    
     -- Collision for obstacle 5
     local function onCollision4(event)
      if event.phase == "began" then
       local player = event.object1
       local op5 = event.object2
        if player.type == "player" and op5.type == "op5" then

          local function trans()
           --composer.gotoScene("gameOver")
          end
          
          if char:currentAnimation() == "back" or char:currentAnimation() == "up" or char:currentAnimation() == "down" or
          char:currentAnimation() == "forward" or char:currentAnimation() == "idle" then
            Runtime:removeEventListener("enterFrame", move)
            Runtime:removeEventListener("enterFrame", move2)
            Runtime:removeEventListener( "enterFrame", main )
            Runtime:removeEventListener("touch", moveAnalog)
            --physics.stop()
            transition.cancel("transTag")
            timer:pauseAllTimers()
            music.remove()
            char:stop()
            charDies:play({name = "dead"})
            transition.to(charDies, {onComplete = trans})
          end

           --transition.to(char, {onComplete = playDeath})
           --charDies:play({name = "died"})
           
           --score.save()
        end
      end
    end
    
    Runtime:addEventListener("collision", onCollision4)
    
     -- Collision for obstacle 4
     local function onCollision5(event)
      if event.phase == "began" then
       local player = event.object1
       local op4 = event.object2
        if player.type == "player" and op4.type == "op4" then

          local function trans()
           --composer.gotoScene("gameOver")
          end
          
          if char:currentAnimation() == "back" or char:currentAnimation() == "up" or char:currentAnimation() == "down" or
          char:currentAnimation() == "forward" or char:currentAnimation() == "idle" then
            Runtime:removeEventListener("enterFrame", move)
            Runtime:removeEventListener("enterFrame", move2)
            Runtime:removeEventListener( "enterFrame", main )
            Runtime:removeEventListener("touch", moveAnalog)
            --physics.stop()
            transition.cancel("transTag")
            timer:pauseAllTimers()
            music.remove()
            char:stop()
            charDies:play({name = "dead"})
            transition.to(charDies, {onComplete = trans})
          end

           --transition.to(char, {onComplete = playDeath})
           --charDies:play({name = "died"})
           
           --score.save()
        end
      end
    end
    
    Runtime:addEventListener("collision", onCollision5)
    
     -- Collision for obstacle 5
     local function onCollision6(event)
      if event.phase == "began" then
       local player = event.object1
       local op2 = event.object2
        if player.type == "player" and op2.type == "op2" then

          local function trans()
           --composer.gotoScene("gameOver")
          end
          
          if char:currentAnimation() == "back" or char:currentAnimation() == "up" or char:currentAnimation() == "down" or
          char:currentAnimation() == "forward" or char:currentAnimation() == "idle" then
            Runtime:removeEventListener("enterFrame", move)
            Runtime:removeEventListener("enterFrame", move2)
            Runtime:removeEventListener( "enterFrame", main )
            Runtime:removeEventListener("touch", moveAnalog)
            --physics.stop()
            transition.cancel("transTag")
            timer:pauseAllTimers()
            music.remove()
            char:stop()
            charDies:play({name = "dead"})
            transition.to(charDies, {onComplete = trans})
          end

           --transition.to(char, {onComplete = playDeath})
           --charDies:play({name = "died"})
           
           --score.save()
        end
      end
    end
    
    Runtime:addEventListener("collision", onCollision6)
    
     -- Collision for obstacle 5
     local function onCollision7(event)
      if event.phase == "began" then
       local player = event.object1
       local op1 = event.object2
        if player.type == "player" and op1.type == "op1" then

          local function trans()
           --composer.gotoScene("gameOver")
          end
          
          if char:currentAnimation() == "back" or char:currentAnimation() == "up" or char:currentAnimation() == "down" or
          char:currentAnimation() == "forward" or char:currentAnimation() == "idle" then
            Runtime:removeEventListener("enterFrame", move)
            Runtime:removeEventListener("enterFrame", move2)
            Runtime:removeEventListener( "enterFrame", main )
            Runtime:removeEventListener("touch", moveAnalog)
            --physics.stop()
            transition.cancel("transTag")
            timer:pauseAllTimers()
            music.remove()
            char:stop()
            charDies:play({name = "dead"})
            transition.to(charDies, {onComplete = trans})
          end

           --charDies:play({name = "died"})
            
           --score.save()
        end
      end
    end
    
    Runtime:addEventListener("collision", onCollision7)]]--
    
  function highsaveScore()
      if score.get() == 0 then
      print("test")
      elseif
        score.get() > score.load() then
        score.save()
            end
            return true
          end
   

  function firstloadScore( )
      if score.load() == nil then
       score.save()
     end
   end

      function resetScore()
        local prevScore = score.load()
        if prevScore then
          score.reset()
          score.set(0) 
      end
      return true
    end
    
    firstloadScore( )
    resetScore()
    
     local function saveScore( event )
      if event.phase == "ended" then
        score.save()
      end
      return true
    end
  
    local function loadScore( event )
      if event.phase == "ended" then
        local prevScore = score.load()
        if prevScore then
          score.set(prevScore)
        end
      end
      return true
    end
    
    local function highScore(event)
      if event.phase == "ended" then
      local highScore = score.load()
        if score.get() > highScore then
          score.save()
        end
      end
      return true
    end
    
    --[[local saveButton = widget.newButton({width = 200, height = 64, x = display.contentCenterX, y = display.contentHeight - 32,
      label = "Save Score", labelColor = { default = { 1, 1, 1 }, over = { 0, 0, 0 } },
      fontSize = 32, onEvent = saveScore})
      sceneGroup:insert(saveButton)

    local loadButton = widget.newButton({ width = 200, height = 64, x = display.contentCenterX, y = display.contentHeight - 64,
      label = "Load Score", labelColor = { default = { 1, 1, 1 }, over = { 0, 0, 0 } },
      fontSize = 32, onEvent = loadScore})
      sceneGroup:insert(loadButton)]]--
         
    end
end

-- "scene:hide()"
function scene:hide( event )

    local sceneGroup = self.view
    local phase = event.phase

    if ( phase == "will" ) then
        -- Called when the scene is on screen (but is about to go off screen).
        -- Insert code here to "pause" the scene.
        -- Example: stop timers, stop animation, stop audio, etc.
    elseif ( phase == "did" ) then
        -- Called immediately after scene goes off screen.
    end
end


-- "scene:destroy()"
function scene:destroy( event )

    local sceneGroup = self.view

    -- Called prior to the removal of scene's view ("sceneGroup").
    -- Insert code here to clean up the scene.
    -- Example: remove display objects, save state, etc.
    physics.stop()
                
end

-- -------------------------------------------------------------------------------

-- Listener setup
scene:addEventListener( "create", scene )
scene:addEventListener( "show", scene )
scene:addEventListener( "hide", scene )
scene:addEventListener( "destroy", scene )

-- -------------------------------------------------------------------------------

return scene